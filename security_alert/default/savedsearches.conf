# FortiGate Alerts - Simplified Messages (Title Only)
# Version: 2.0.1 - Enhanced Field Parsing
# Last updated: 2025-11-04
#
# Improvements:
# - Simplified Slack messages to single-line title format
# - Enhanced field parsing with coalesce() and case() statements
# - Fixed LogID definitions based on actual sample data
# - Added state transition tracking (HA alerts)
# - Implemented baseline anomaly detection (Alert 006)
# - Removed non-existent field extractions (cfgold/cfgnew)

[001_Config_Change]
description = Configuration change detection with detailed before/after tracking
search = `fortigate_index` `logids_config_change` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval user = coalesce(user, "system") \
| eval method = case(logid="0100044546", "CLI", logid="0100044547", "GUI", true(), coalesce(ui, "N/A")) \
| eval config_path = coalesce(cfgpath, "unknown") \
| eval config_attr = coalesce(cfgattr, "-") \
| eval change_type = case( \
    like(config_path, "%firewall%policy%"), "üîí Firewall Policy", \
    like(config_path, "%firewall%address%"), "üè† Address Object", \
    like(config_path, "%firewall%service%"), "üîå Service Object", \
    like(config_path, "%router%"), "üåê Routing", \
    like(config_path, "%system%interface%"), "üîß Interface", \
    like(config_path, "%system%admin%"), "üë§ Admin Account", \
    like(config_path, "%vpn%"), "üîê VPN", \
    like(config_path, "%system%global%"), "‚öôÔ∏è Global Settings", \
    like(config_path, "%log%"), "üìù Logging", \
    true(), "üìã Other") \
| rex field=msg "from\s+['\"]?(?<value_before>[^'\"]+)['\"]?\s+to\s+['\"]?(?<value_after>[^'\"]+)['\"]?" \
| rex field=config_attr "set\s+(?<attr_name>\S+)\s+['\"]?(?<attr_value>[^'\"]+)['\"]?" \
| eval value_before = coalesce(value_before, "-") \
| eval value_after = coalesce(value_after, attr_value, config_attr) \
| eval clean_before = if(len(value_before) > 40, substr(value_before, 1, 37) + "...", value_before) \
| eval clean_after = if(len(value_after) > 40, substr(value_after, 1, 37) + "...", value_after) \
| rex mode=sed field=clean_before "s/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[UUID]/g" \
| rex mode=sed field=clean_after "s/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[UUID]/g" \
| eval clean_before = trim(clean_before) \
| eval clean_after = trim(clean_after) \
| eval change_summary = if(clean_before != "-", "FROM: " . clean_before . " ‚ûú TO: " . clean_after, "SET: " . clean_after) \
| eval criticality = case( \
    like(config_path, "%firewall%policy%") OR like(config_path, "%system%admin%"), "üî¥ HIGH", \
    like(config_path, "%vpn%") OR like(config_path, "%router%"), "üü† MEDIUM", \
    true(), "üü¢ LOW") \
| eval short_path = if(len(config_path) > 50, "..." . substr(config_path, len(config_path)-47, 50), config_path) \
| eval formatted_message = change_type . " | " . short_path . " | " . change_summary \
| table _time, device, user, method, formatted_message, criticality

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 1
alert.suppress.fields = device,user,config_path
alert.suppress.period = 10m
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[007_Hardware_Failure]
description = Hardware component failure detection with EMS-style state tracking
search = `fortigate_index` `logids_hardware_failure` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval component = case( \
    like(msg, "%fan%") OR like(msg, "%Fan%"), "Fan", \
    like(msg, "%power%") OR like(msg, "%Power%"), "PSU", \
    like(msg, "%temp%") OR like(msg, "%Temp%"), "Temperature", \
    like(msg, "%disk%") OR like(msg, "%Disk%"), "Disk", \
    true(), "Hardware") \
| rex field=msg "(?i)(?<component_detail>fan\s*\d+|psu\s*\d+|sensor\s*\d+)" \
| rex field=msg "(?<temp_value>\d+)¬∞C" \
| rex field=msg "(?<threshold>\d+)%" \
| eval component_detail = upper(coalesce(component_detail, "-")) \
| eval temp_value = coalesce(temp_value, "-") \
| eval threshold = coalesce(threshold, "-") \
| eval severity = case( \
    component="PSU" OR component="Temperature", "üî¥ CRITICAL", \
    component="Fan", "üü† HIGH", \
    true(), "üü° MEDIUM") \
| eval status_info = case( \
    temp_value != "-", "Temp: " . temp_value . "¬∞C", \
    threshold != "-", "Usage: " . threshold . "%", \
    true(), "") \
| eval formatted_message = component . " " . component_detail . " | Status: FAILED" . if(status_info != "", " | " . status_info, "") \
| eval current_state = "FAIL" \
| stats latest(_time) as last_seen, latest(formatted_message) as formatted_message, \
        latest(severity) as severity, latest(current_state) as current_state \
  by device, component \
| join type=left device component [ \
    | inputlookup hardware_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!="FAIL", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t hardware_state_tracker \
| table last_seen, device, formatted_message, severity

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 5
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[007_Hardware_Restored]
description = Hardware component restoration detection with EMS-style state tracking
search = `fortigate_index` (logid=0103040014 OR logid=0103040015) \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval component = case( \
    like(msg, "%fan%") OR like(msg, "%Fan%"), "Fan", \
    like(msg, "%power%") OR like(msg, "%Power%"), "PSU", \
    like(msg, "%temp%") OR like(msg, "%Temp%"), "Temperature", \
    like(msg, "%disk%") OR like(msg, "%Disk%"), "Disk", \
    true(), "Hardware") \
| rex field=msg "(?i)(?<component_detail>fan\s*\d+|psu\s*\d+|sensor\s*\d+)" \
| eval component_detail = upper(coalesce(component_detail, "-")) \
| eval formatted_message = component . " " . component_detail . " | Status: RESTORED" \
| eval current_state = "OK" \
| stats latest(_time) as last_seen, latest(formatted_message) as formatted_message, \
        latest(current_state) as current_state \
  by device, component \
| join type=left device component [ \
    | inputlookup hardware_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(previous_state="FAIL" AND current_state="OK", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t hardware_state_tracker \
| table last_seen, device, formatted_message

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 3
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[008_HA_State_Change]
description = HA cluster state changes with EMS-style state tracking
search = `fortigate_index` `logids_ha_state` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval ha_state = coalesce(ha_state, "unknown") \
| eval from_state = coalesce(from_state, "-") \
| eval transition = if(from_state != "-", from_state . " ‚Üí " . ha_state, ha_state) \
| eval member = coalesce(member, serial, "-") \
| eval clean_member = if(len(member) > 30, substr(member, 1, 27) + "...", member) \
| rex mode=sed field=clean_member "s/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/[UUID]/g" \
| eval clean_member = trim(clean_member) \
| eval role = case( \
    like(ha_state, "%master%") OR like(ha_state, "%primary%"), "PRIMARY", \
    like(ha_state, "%slave%") OR like(ha_state, "%secondary%"), "SECONDARY", \
    like(ha_state, "%standalone%"), "STANDALONE", \
    true(), "UNKNOWN") \
| eval criticality = case( \
    like(transition, "%‚Üí%"), "üü† CHANGE", \
    ha_state="standalone" OR ha_state="alone", "üî¥ CRITICAL", \
    true(), "üü¢ NORMAL") \
| rex field=msg "reason:\s*(?<reason>[^,\.]+)" \
| eval reason = coalesce(reason, "-") \
| eval clean_reason = if(len(reason) > 50, substr(reason, 1, 47) + "...", reason) \
| eval formatted_message = role . " | Transition: " . transition . " | Member: " . clean_member . " | Reason: " . clean_reason \
| eval current_state = ha_state \
| stats latest(_time) as last_seen, latest(formatted_message) as formatted_message, \
        latest(criticality) as criticality, latest(current_state) as current_state \
  by device \
| join type=left device [ \
    | inputlookup ha_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t ha_state_tracker \
| table last_seen, device, formatted_message, criticality

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[010_Resource_Limit]
description = System resource exhaustion with threshold state tracking (EXCEEDED/NORMAL)
search = `fortigate_index` `logids_resource_limit` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval resource_type = case( \
    like(msg, "%disk%") OR like(msg, "%Disk%"), "Disk", \
    like(msg, "%session%") OR like(msg, "%Session%"), "Sessions", \
    like(msg, "%memory%") OR like(msg, "%Memory%"), "Memory", \
    like(msg, "%cpu%") OR like(msg, "%CPU%"), "CPU", \
    true(), "Resource") \
| rex field=msg "(?<usage_pct>\d+)%" \
| rex field=msg "limit\s+(?<limit_value>\d+)" \
| rex field=msg "current\s+(?<current_value>\d+)" \
| eval usage_pct = tonumber(coalesce(usage_pct, "0")) \
| eval limit_value = coalesce(limit_value, "-") \
| eval current_value = coalesce(current_value, "-") \
| eval usage = usage_pct . "%" \
| eval severity = case( \
    usage_pct >= 95, "üî¥ CRITICAL", \
    usage_pct >= 85, "üü† HIGH", \
    usage_pct >= 75, "üü° MEDIUM", \
    true(), "üü¢ LOW") \
| eval remaining = if(isnum(limit_value) AND isnum(current_value), (tonumber(limit_value) - tonumber(current_value)), "-") \
| eval formatted_message = resource_type . " | Usage: " . usage . if(remaining != "-", " | Remaining: " . remaining, "") \
| eval current_state = if(usage_pct >= 75, "EXCEEDED", "NORMAL") \
| stats latest(_time) as last_seen, latest(formatted_message) as formatted_message, \
        latest(severity) as severity, latest(current_state) as current_state \
  by device, resource_type \
| join type=left device resource_type [ \
    | inputlookup resource_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t resource_state_tracker \
| where current_state="EXCEEDED" \
| table _time, device, formatted_message, severity

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 5
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[011_Admin_Login_Failed]
description = Admin login failure with brute force pattern detection and state tracking (ATTACK/NORMAL)
search = `fortigate_index` `logids_admin_login` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval user = coalesce(user, "unknown") \
| eval source_ip = coalesce(srcip, ui, "-") \
| eval method = coalesce(authproto, "Unknown") \
| rex field=source_ip "(?<src_country>[A-Z]{2})" \
| eval src_country = coalesce(src_country, "-") \
| stats count as fail_count, earliest(_time) as first_time, latest(_time) as last_time, values(user) as users, values(method) as methods by device, source_ip \
| eval duration = tostring(last_time - first_time, "duration") \
| eval attack_type = case( \
    fail_count >= 10, "üî¥ Brute Force", \
    fail_count >= 5, "üü† Suspicious", \
    fail_count >= 3, "üü° Failed Login", \
    true(), "üü¢ Normal") \
| eval unique_users = mvcount(users) \
| eval details = fail_count . " failures in " . duration \
| eval current_state = if(fail_count >= 3, "ATTACK", "NORMAL") \
| stats latest(first_time) as first_time, latest(fail_count) as fail_count, latest(duration) as duration, \
        latest(attack_type) as attack_type, latest(unique_users) as unique_users, latest(details) as details, \
        latest(users) as users, latest(methods) as methods, latest(current_state) as current_state \
  by device, source_ip \
| join type=left device source_ip [ \
    | inputlookup admin_login_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t admin_login_state_tracker \
| where current_state="ATTACK" \
| table first_time, device, source_ip, users, unique_users, fail_count, duration, attack_type, methods, details

cron_schedule = * * * * *
enableSched = 0
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 5
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[012_Interface_Down]
description = Network interface DOWN detection with EMS-style state tracking
search = `fortigate_index` `logids_link_monitor` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval interface = coalesce(interface, port, "-") \
| search msg="*down*" OR msg="*Down*" \
| eval status = "DOWN" \
| rex field=interface "(?<if_type>port|wan|lan|dmz)" \
| eval if_type = upper(coalesce(if_type, "OTHER")) \
| rex field=msg "speed:\s*(?<link_speed>\d+)" \
| rex field=msg "duplex:\s*(?<duplex>\w+)" \
| eval link_speed = coalesce(link_speed, "-") . "Mbps" \
| eval duplex = coalesce(duplex, "-") \
| eval details = coalesce(msg, "-") \
| eval current_state = "DOWN" \
| stats latest(_time) as last_seen, latest(if_type) as if_type, latest(link_speed) as link_speed, \
        latest(duplex) as duplex, latest(details) as details, latest(current_state) as current_state \
  by device, interface \
| join type=left device interface [ \
    | inputlookup interface_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!="DOWN", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t interface_state_tracker \
| table last_seen, device, interface, if_type, link_speed, duplex, details

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[012_Interface_Up]
description = Network interface UP detection (recovery) with EMS-style state tracking
search = `fortigate_index` `logids_link_monitor` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval interface = coalesce(interface, port, "-") \
| search msg="*up*" OR msg="*Up*" \
| eval status = "UP" \
| rex field=interface "(?<if_type>port|wan|lan|dmz)" \
| eval if_type = upper(coalesce(if_type, "OTHER")) \
| rex field=msg "speed:\s*(?<link_speed>\d+)" \
| rex field=msg "duplex:\s*(?<duplex>\w+)" \
| eval link_speed = coalesce(link_speed, "-") . "Mbps" \
| eval duplex = coalesce(duplex, "-") \
| eval details = coalesce(msg, "-") \
| eval current_state = "UP" \
| stats latest(_time) as last_seen, latest(if_type) as if_type, latest(link_speed) as link_speed, \
        latest(duplex) as duplex, latest(details) as details, latest(current_state) as current_state \
  by device, interface \
| join type=left device interface [ \
    | inputlookup interface_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(previous_state="DOWN" AND current_state="UP", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t interface_state_tracker \
| table last_seen, device, interface, if_type, link_speed, duplex, details

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 3
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[002_VPN_Tunnel_Down]
description = VPN tunnel failure detection with EMS-style state tracking
search = `fortigate_index` `logids_vpn_tunnel` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval vpn_name = coalesce(tunnelid, vpnname, tunnelname, "-") \
| eval remote_ip = coalesce(remip, dstip, "-") \
| eval local_ip = coalesce(srcip, locip, "-") \
| eval event = case( \
    logid="0101037124", "Tunnel Down", \
    logid="0101037131", "Phase1 Fail", \
    logid="0101037134", "Phase2 Fail", \
    true(), "VPN Issue") \
| rex field=msg "(?i)reason:\s*(?<failure_reason>[^,\.]+)" \
| rex field=msg "(?i)error:\s*(?<error_code>\d+)" \
| eval failure_reason = coalesce(failure_reason, "Unknown") \
| eval error_code = coalesce(error_code, "-") \
| eval vpn_type = case( \
    like(vpn_name, "%SSL%") OR like(vpn_name, "%ssl%"), "SSL-VPN", \
    like(vpn_name, "%IPsec%") OR like(vpn_name, "%ipsec%"), "IPsec", \
    true(), "VPN") \
| eval criticality = if(event="Tunnel Down", "üî¥ CRITICAL", "üü† HIGH") \
| eval current_state = "DOWN" \
| stats latest(_time) as last_seen, latest(remote_ip) as remote_ip, latest(local_ip) as local_ip, \
        latest(event) as event, latest(failure_reason) as failure_reason, latest(error_code) as error_code, \
        latest(vpn_type) as vpn_type, latest(criticality) as criticality, latest(current_state) as current_state \
  by device, vpn_name \
| join type=left device vpn_name [ \
    | inputlookup vpn_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!="DOWN", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t vpn_state_tracker \
| table last_seen, device, vpn_name, vpn_type, remote_ip, local_ip, event, failure_reason, error_code, criticality

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 5
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[002_VPN_Tunnel_Up]
description = VPN tunnel recovery detection with EMS-style state tracking
search = `fortigate_index` (logid=0101037125 OR logid=0101037132) \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval vpn_name = coalesce(tunnelid, vpnname, tunnelname, "-") \
| eval remote_ip = coalesce(remip, dstip, "-") \
| eval local_ip = coalesce(srcip, locip, "-") \
| eval event = case( \
    logid="0101037125", "Phase1 Up", \
    logid="0101037132", "Tunnel Up", \
    true(), "VPN Restored") \
| eval vpn_type = case( \
    like(vpn_name, "%SSL%") OR like(vpn_name, "%ssl%"), "SSL-VPN", \
    like(vpn_name, "%IPsec%") OR like(vpn_name, "%ipsec%"), "IPsec", \
    true(), "VPN") \
| eval current_state = "UP" \
| stats latest(_time) as last_seen, latest(remote_ip) as remote_ip, latest(local_ip) as local_ip, \
        latest(event) as event, latest(vpn_type) as vpn_type, latest(current_state) as current_state \
  by device, vpn_name \
| join type=left device vpn_name [ \
    | inputlookup vpn_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(previous_state="DOWN" AND current_state="UP", 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t vpn_state_tracker \
| table last_seen, device, vpn_name, vpn_type, remote_ip, local_ip, event

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-5m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 5
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 12h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[006_CPU_Memory_Anomaly]
description = CPU and Memory anomaly detection with EMS-style state tracking (20% threshold)
search = `fortigate_index` `logids_cpu_memory` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| rex field=msg "(?i)(cpu|memory)[^\d]*(?<current_value>\d+)%" \
| eval current_value = tonumber(current_value) \
| eval resource = case( \
    like(msg, "%CPU%") OR like(msg, "%cpu%"), "CPU", \
    like(msg, "%memory%") OR like(msg, "%Memory%"), "Memory", \
    true(), "Unknown") \
| eventstats avg(current_value) as baseline_avg by device, resource \
| eval baseline_avg = round(baseline_avg, 1) \
| eval deviation_pct = round(((current_value - baseline_avg) / baseline_avg) * 100, 1) \
| eval current_state = if(deviation_pct > 20, "ABNORMAL", "NORMAL") \
| eval details = "Current: " . current_value . "% | Baseline: " . baseline_avg . "% | Deviation: " . deviation_pct . "%" \
| stats latest(_time) as last_seen, latest(current_value) as current_value, latest(baseline_avg) as baseline_avg, \
        latest(deviation_pct) as deviation_pct, latest(details) as details, latest(current_state) as current_state \
  by device, resource \
| join type=left device resource [ \
    | inputlookup cpu_memory_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t cpu_memory_state_tracker \
| where current_state="ABNORMAL" \
| table last_seen, device, resource, current_value, baseline_avg, deviation_pct, details

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[013_SSL_VPN_Brute_Force]
description = SSL VPN brute force attack detection with state tracking (ATTACK/NORMAL)
search = `fortigate_index` `logids_ssl_vpn_failed` earliest=rt-10m latest=rt \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval source_ip = coalesce(srcip, "unknown") \
| eval user = coalesce(user, "N/A") \
| eval reason = coalesce(reason, msg) \
| stats count as fail_count, \
    earliest(_time) as first_seen, \
    latest(_time) as last_seen, \
    dc(user) as unique_users, \
    values(user) as attempted_users \
    by device, source_ip \
| eval duration_sec = last_seen - first_seen \
| eval duration = tostring(duration_sec, "duration") \
| eval attack_type = case( \
    fail_count >= 20, "üî¥ Severe Brute Force", \
    fail_count >= 10, "üü† Brute Force", \
    unique_users >= 5, "üü° User Enumeration", \
    fail_count >= 5, "‚ö†Ô∏è Suspicious Activity", \
    true(), "üü¢ Normal") \
| eval criticality = if(fail_count >= 10, "CRITICAL", "HIGH") \
| eval current_state = if(fail_count >= 5, "ATTACK", "NORMAL") \
| stats latest(first_seen) as first_seen, latest(last_seen) as last_seen, latest(fail_count) as fail_count, \
        latest(unique_users) as unique_users, latest(attempted_users) as attempted_users, \
        latest(duration) as duration, latest(attack_type) as attack_type, latest(criticality) as criticality, \
        latest(current_state) as current_state \
  by device, source_ip \
| join type=left device source_ip [ \
    | inputlookup vpn_brute_force_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t vpn_brute_force_state_tracker \
| where current_state="ATTACK" \
| table first_seen, device, source_ip, fail_count, unique_users, attempted_users, duration, attack_type, criticality

cron_schedule = * * * * *
enableSched = 0
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[015_Abnormal_Traffic_Spike]
description = Traffic volume anomaly detection with state tracking (SPIKE/NORMAL)
search = `fortigate_index` `logids_traffic` earliest=rt-35m latest=rt \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval source_ip = coalesce(srcip, "unknown") \
| eval dest_ip = coalesce(dstip, "unknown") \
| eval protocol = coalesce(proto, "unknown") \
| eval bytes = coalesce(sentbyte, 0) + coalesce(rcvdbyte, 0) \
| bin _time span=5m \
| stats sum(bytes) as total_bytes, count as session_count by _time, device, source_ip, protocol \
| eventstats avg(total_bytes) as baseline_avg, stdev(total_bytes) as baseline_stdev by device, source_ip, protocol \
| eval baseline_avg = round(baseline_avg, 0) \
| eval spike_multiplier = round(total_bytes / baseline_avg, 1) \
| eval traffic_mb = round(total_bytes / 1024 / 1024, 2) \
| eval baseline_mb = round(baseline_avg / 1024 / 1024, 2) \
| eval severity = case( \
    spike_multiplier >= 10, "üî¥ CRITICAL (10x)", \
    spike_multiplier >= 5, "üü† HIGH (5x)", \
    spike_multiplier >= 3, "üü° MEDIUM (3x)", \
    true(), "üü¢ Normal") \
| eval anomaly_type = case( \
    session_count >= 1000, "üìä Session Flood", \
    traffic_mb >= 1000, "üíæ Bandwidth Spike", \
    spike_multiplier >= 3, "‚ö†Ô∏è Volume Anomaly", \
    true(), "Normal Traffic") \
| eval current_state = if(spike_multiplier >= 3, "SPIKE", "NORMAL") \
| stats latest(_time) as last_seen, latest(traffic_mb) as traffic_mb, latest(baseline_mb) as baseline_mb, \
        latest(spike_multiplier) as spike_multiplier, latest(session_count) as session_count, \
        latest(anomaly_type) as anomaly_type, latest(severity) as severity, latest(current_state) as current_state \
  by device, source_ip \
| join type=left device source_ip [ \
    | inputlookup traffic_spike_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t traffic_spike_state_tracker \
| where current_state="SPIKE" \
| table last_seen, device, source_ip, traffic_mb, baseline_mb, spike_multiplier, session_count, anomaly_type, severity

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[016_System_Reboot]
description = Unexpected system reboot or crash detection
search = `fortigate_index` `logids_system_reboot` earliest=rt-10m latest=rt \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval event_type = case( \
    logid="0100032002", "System Reboot", \
    logid="0100032003", "System Crash", \
    logid="0100032004", "Kernel Panic", \
    true(), coalesce(subtype, "System Event")) \
| rex field=msg "(?i)reason[:\s]+(?<reboot_reason>[^,\.]+)" \
| rex field=msg "(?i)initiated by\s+(?<initiated_by>[^\s,]+)" \
| eval reboot_reason = coalesce(reboot_reason, "Unknown") \
| eval initiated_by = coalesce(initiated_by, "system") \
| eval reboot_type = case( \
    like(lower(reboot_reason), "%upgrade%") OR like(lower(reboot_reason), "%maintenance%"), "‚úÖ Planned", \
    like(lower(reboot_reason), "%crash%") OR like(lower(reboot_reason), "%panic%"), "üî¥ Crash", \
    like(initiated_by, "admin") OR like(initiated_by, "user"), "üü° Manual", \
    true(), "‚ö†Ô∏è Unexpected") \
| eval criticality = case( \
    event_type="System Crash" OR event_type="Kernel Panic", "üî¥ CRITICAL", \
    reboot_type="‚ö†Ô∏è Unexpected", "üü† HIGH", \
    true(), "üü¢ INFO") \
| eval uptime_before = coalesce(uptime, "N/A") \
| table _time, device, event_type, reboot_type, reboot_reason, initiated_by, uptime_before, criticality

cron_schedule = * * * * *
enableSched = 1
realtime_schedule = 1
dispatch.earliest_time = rt-10m
dispatch.latest_time = rt
alert.track = 1
alert.severity = 4
alert.digest_mode = 0
alert.suppress = 1
alert.suppress.fields = device
alert.suppress.period = 10m
alert.expires = 24h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0


[017_License_Expiry_Warning]
description = FortiGate license expiration warning with state tracking (WARNING/NORMAL)
search = `fortigate_index` `logids_license_warning` \
| `enrich_with_logid_lookup` \
| eval device = coalesce(devname, "unknown") \
| eval license_type = coalesce(license, "Unknown License") \
| rex field=msg "(?i)expires?\s+(?:in\s+)?(?<days_remaining>\d+)\s+days?" \
| rex field=msg "(?i)expir(?:y|ation)\s+date[:\s]+(?<expiry_date>[\d\-/]+)" \
| eval days_remaining = tonumber(coalesce(days_remaining, "999")) \
| eval urgency = case( \
    days_remaining <= 7, "üî¥ URGENT (‚â§7 days)", \
    days_remaining <= 14, "üü† HIGH (‚â§14 days)", \
    days_remaining <= 30, "üü° MEDIUM (‚â§30 days)", \
    true(), "üü¢ OK") \
| eval license_category = case( \
    like(license_type, "%FortiCare%"), "üõ°Ô∏è FortiCare Support", \
    like(license_type, "%FortiGuard%"), "üîí FortiGuard Services", \
    like(license_type, "%IPS%"), "üéØ IPS Subscription", \
    like(license_type, "%AV%") OR like(license_type, "%antivirus%"), "ü¶† Antivirus", \
    like(license_type, "%Web%"), "üåê Web Filtering", \
    like(license_type, "%VM%"), "‚òÅÔ∏è VM License", \
    true(), "üìã " . license_type) \
| eval expiry_date = coalesce(expiry_date, "Not specified") \
| eval action_required = if(days_remaining <= 14, "‚ö†Ô∏è Renew immediately", "üìÖ Plan renewal") \
| eval current_state = if(days_remaining <= 30, "WARNING", "NORMAL") \
| stats latest(_time) as last_seen, latest(days_remaining) as days_remaining, latest(expiry_date) as expiry_date, \
        latest(urgency) as urgency, latest(action_required) as action_required, latest(current_state) as current_state \
  by device, license_category \
| join type=left device license_category [ \
    | inputlookup license_state_tracker \
    | rename state as previous_state ] \
| eval state_changed = if(isnull(previous_state) OR previous_state!=current_state, 1, 0) \
| where state_changed=1 \
| eval state = current_state \
| outputlookup append=t license_state_tracker \
| where current_state="WARNING" \
| table last_seen, device, license_category, days_remaining, expiry_date, urgency, action_required

cron_schedule = */5 * * * *
enableSched = 0
realtime_schedule = 0
dispatch.earliest_time = -10m
dispatch.latest_time = now
alert.track = 1
alert.severity = 3
alert.digest_mode = 0
alert.suppress = 0
alert.expires = 48h

action.slack = 1
action.slack.param.channel = #security-firewall-alert

dispatch.rt_backfill = 1
auto_summarize = 0
